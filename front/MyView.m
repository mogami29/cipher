#import "MyView.h"@implementation MyView- (void) drawRect : (NSRect) rect{//    [[NSColor whiteColor] set];//    NSRectFill([self bounds]);   // Equiv to [[NSBezierPath bezierPathWithRect:[self bounds]] fill]	NSMutableDictionary *dicAttr = [ NSMutableDictionary dictionary ];    NSFont *fontAttr;    [ dicAttr setObject : [ NSColor blueColor ]                forKey  : NSForegroundColorAttributeName ];                    fontAttr = [ NSFont fontWithName : @"Helvetica"                                size : 24 ];    [ dicAttr setObject : fontAttr                forKey  : NSFontAttributeName];    NSAttributedString* str = [[NSAttributedString alloc] initWithString:line attributes:dicAttr];    //[line   drawAtPoint : NSMakePoint( 10, 10 )	//	 withAttributes : dicAttr ];    //[str drawAtPoint : NSMakePoint( 10, 10 )];    if (cursorOn){        CGFloat w = [str size].width;                NSPoint	point0 = {w + 10, 10 - [fontAttr descender]};        NSPoint	point1 = {w + 10, 10 - [fontAttr descender] + [fontAttr ascender]};        [NSBezierPath strokeLineFromPoint:point0 toPoint:point1];    }        // taken from Core Text:Common Operations    // Initialize a graphics context and set the text matrix to a known value.    CGContextRef context = (CGContextRef)[[NSGraphicsContext currentContext]                                          graphicsPort];    CGContextSetTextMatrix(context, CGAffineTransformMakeScale(1, -1));        // Create a typesetter using the attributed string.    CTTypesetterRef typesetter = CTTypesetterCreateWithAttributedString((__bridge CFAttributedStringRef)(str));        // Find a break for line from the beginning of the string to the given width.    CFIndex start = 0;    CFIndex count = CTTypesetterSuggestLineBreak(typesetter, start, 200);        // Use the returned character count (to the break) to create the line.    CTLineRef aline = CTTypesetterCreateLine(typesetter, CFRangeMake(start, count));        // Get the offset needed to center the line.//    float flush = 0.5; // centered//    double penOffset = CTLineGetPenOffsetForFlush(line, flush, width);        // Move the given text drawing position by the calculated offset and draw the line.    CGContextSetTextPosition(context, 10, 10);    CTLineDraw(aline, context);        // Move the index beyond the line break.    start += count;//*/}- (void) awakeFromNib{    NSLog( @"awakeFromNib" );    [ [ self window ] makeFirstResponder : self ];    line = [[NSMutableString alloc] init];        cursorOn = 1;    [self startAnimation];}- (void) keyDown : (NSEvent *) theEvent{    NSString* hoge = [theEvent characters];//	BOOL bar = [hoge isEqualToString: @"\n"];//	bar;    cursorOn = true;    [line appendString: hoge];    [self display];}- (BOOL)isFlipped{    return YES;}- (void) mouseDown:(NSEvent *)theEvent{    [line setString: @"hoge"];    [self display];}// taken from Circleview- (void) startAnimation {    [self stopAnimation];        // We schedule a timer for a desired 30fps animation rate.    // In performAnimation: we determine exactly    // how much time has elapsed and animate accordingly.    timer = [NSTimer scheduledTimerWithTimeInterval:(1.0/2.0) target:self selector:@selector(performAnimation:) userInfo:nil repeats:YES];        // The next two lines make sure that animation will continue to occur    // while modal panels are displayed and while event tracking is taking    // place (for example, while a slider is being dragged).    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSModalPanelRunLoopMode];    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSEventTrackingRunLoopMode];    //    lastTime = [NSDate timeIntervalSinceReferenceDate];}- (void) stopAnimation {    [timer invalidate];//    [timer release];    timer = nil;}- (void) toggleAnimation {    if (timer != nil) {        [self stopAnimation];    } else {        [self startAnimation];    }}- (void)performAnimation:(NSTimer *)aTimer {    // We determine how much time has elapsed since the last animation,    // and we advance the angle accordingly.    NSTimeInterval thisTime = [NSDate timeIntervalSinceReferenceDate];    cursorOn = !cursorOn;    //    lastTime = thisTime;    [self setNeedsDisplay:YES];    // use later: - (void)setNeedsDisplayInRect:(NSRect)invalidRect}@end